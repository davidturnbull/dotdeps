## Iteration 1 - task-001: CLI argument parsing

### Completed
- Set up Cargo project with Rust 2024 edition
- Implemented CLI argument parsing with clap derive macros
- Supports: add, remove, list subcommands and --clean flag
- Parses ecosystem:package@version syntax correctly
- Handles scoped packages (@org/pkg), Go module paths, version prefixes (v)
- Normalizes package names to lowercase and strips v prefix from versions
- 12 unit tests pass

### Key decisions
- Used clap derive API for declarative argument parsing
- DepSpec struct with FromStr for parsing dependency specifications
- Ecosystem enum with FromStr supporting aliases (npm->node, cargo->rust, etc.)
- Handle --clean vs subcommand conflict in main() rather than clap attribute

### Files changed
- Cargo.toml (new)
- src/main.rs (new)
- src/cli.rs (new)
- README.md (new)
- .ralph/prd.json (updated task-001 passes: true)

### Next
- task-002: Implement cache and .deps directory structure

## Iteration 2 - task-002 & task-005: Cache and .deps directory structure

### Completed
- Implemented cache module for ~/.cache/dotdeps/<ecosystem>/<package>/<version>/
- Implemented deps module for .deps/<ecosystem>/<package> symlinks
- Created symlinks with absolute paths to cache
- Windows detection with copy_dir_recursive fallback
- List command with broken symlink detection
- Remove command (removes symlink, preserves cache)
- Clean command (removes entire .deps/)
- Handles nested paths: scoped npm (@org/pkg), Go modules (github.com/org/repo/v2)
- XDG_CACHE_HOME environment variable respected
- 21 unit tests pass

### Key decisions
- Used `dirs` crate for cross-platform home directory detection
- Symlinks use absolute paths for reliability
- Cache existence checked via .git directory presence
- Empty ecosystem directories cleaned up on remove
- path and target fields in DepEntry kept for future debugging use

### Files changed
- Cargo.toml (added dirs dependency)
- src/main.rs (wired up cache and deps modules)
- src/cache.rs (new)
- src/deps.rs (new)
- README.md (updated status)
- .ralph/prd.json (task-002 and task-005 passes: true)

### Verified behavior
- `dotdeps add python:requests@2.31.0` creates symlink at .deps/python/requests
- `dotdeps add node:@org/pkg@4.17.21` handles scoped packages
- `dotdeps add go:github.com/org/repo/v2@1.0.0` handles Go module paths
- `dotdeps list` shows ecosystem:package@version format
- `dotdeps list` detects broken symlinks (cache evicted)
- `dotdeps remove python:requests` removes symlink, preserves cache
- `dotdeps --clean` removes entire .deps/ directory

### Next
- task-003: Implement git cloning with tag resolution

## Iteration 3 - task-003: Git cloning with tag resolution

### Completed
- Created git module with shallow clone functionality (--depth 1)
- Implemented tag resolution order: v{version} -> {version} -> default branch
- Added warning message when falling back to default branch
- Implemented cleanup of partial clone directories on failure
- Added Go ecosystem repo URL detection from module path
  - github.com/* -> https://github.com/*.git
  - golang.org/x/* -> https://go.googlesource.com/*.git
- 22 unit tests pass

### Key decisions
- Used std::process::Command for git operations (no external crate needed)
- CloneResult struct returns whether default branch was used and which ref was cloned
- Go modules get special treatment since package path IS the repo URL
- Other ecosystems return clear error message directing to config.json override
- Parent directories left in cache on failure (empty, no harm)

### Files changed
- src/git.rs (new)
- src/main.rs (wired in git module, added detect_repo_url function)
- README.md (updated status)
- .ralph/prd.json (task-003 passes: true)

### Verified behavior
- `dotdeps add go:github.com/gin-gonic/gin@1.9.1` clones at v1.9.1 tag
- `dotdeps add go:golang.org/x/sync@0.6.0` clones from go.googlesource.com
- Cache hit on second add of same package
- Nonexistent tag falls back to default branch with warning
- Clone failure cleans up partial directory
- Non-Go ecosystems show clear error about missing repo detection

### Next
- task-004: Implement Python ecosystem lockfile parsing and PyPI repo detection

## Iteration 4 - task-004: Python ecosystem lockfile parsing and PyPI repo detection

### Completed
- Created python module with lockfile and pypi submodules
- Implemented lockfile parsing for:
  - poetry.lock (TOML [[package]] array)
  - uv.lock (TOML [[package]] array)
  - requirements.txt (exact pins: package==version)
  - pyproject.toml (tool.poetry.dependencies and project.dependencies PEP 621)
- Implemented PyPI repo URL detection via JSON API
  - Checks project_urls for Source, Repository, GitHub keys
  - Falls back to home_page if it looks like a git repo
- Integrated lockfile lookup into add command when version is omitted
- Python package names normalized (case-insensitive, - and _ equivalent)
- 35 unit tests pass

### Key decisions
- Used toml crate for TOML parsing with serde deserialization
- Used ureq for HTTP requests (minimal dependency footprint)
- Used serde_json for PyPI JSON API parsing
- Lockfile search walks up directory tree to find nearest lockfile
- Lockfile priority: poetry.lock > uv.lock > requirements.txt > pyproject.toml
- requirements.txt only returns exact versions (== pins) for reliability
- pyproject.toml supports both Poetry-style and PEP 621-style dependencies
- Go repo detection refactored to use regex-like version suffix stripping

### Files changed
- Cargo.toml (added serde, serde_json, toml, ureq dependencies)
- src/main.rs (added python module, lookup_version function, updated detect_repo_url)
- src/python.rs (new - module root)
- src/python/lockfile.rs (new - lockfile parsing)
- src/python/pypi.rs (new - PyPI API integration)
- README.md (updated status and examples)
- .ralph/prd.json (task-004 passes: true)

### Verified behavior
- `dotdeps add python:requests` reads version from poetry.lock/uv.lock/etc.
- `dotdeps add python:flask` fetches from PyPI, clones repo at correct tag
- `dotdeps add python:typing-extensions` normalizes package name with hyphens
- `dotdeps add python:httpx@0.25.0` explicit version overrides lockfile
- Version not in lockfile shows helpful error message
- No lockfile found shows clear error message
- Cache hit reuses cached clone
- `dotdeps list` shows correct versions

### Next
- Implement Node.js ecosystem (pnpm-lock.yaml, yarn.lock, package-lock.json, npm registry)

## Iteration 5 - task-006: Node.js ecosystem lockfile parsing and npm registry detection

### Completed
- Created node module with lockfile and npm submodules
- Implemented lockfile parsing for:
  - pnpm-lock.yaml (YAML, lockfileVersion 9.0)
  - yarn.lock (custom format, not YAML - line-based parser)
  - package-lock.json (JSON, lockfileVersion 1, 2, and 3)
- Implemented npm registry repo URL detection
  - Handles repository field as string or object
  - Handles various URL formats: git+https, git://, git@, github: shorthand
  - Falls back to homepage if it looks like a git repo
- Scoped packages (@org/pkg) handled correctly in all parsers
- Package names normalized to lowercase for cache consistency
- 60 unit tests pass

### Key decisions
- Used serde_yml for YAML parsing
- yarn.lock is NOT valid YAML - implemented custom line-based parser
- Package version extracted from lockfile key (name@version) rather than nested structure
- npm repository URL normalization handles many edge cases (git+, ssh, shorthand)
- is_known_git_host() checks for known hosts before adding .git suffix

### Files changed
- Cargo.toml (added serde_yml dependency)
- src/main.rs (added node module, wired lockfile and repo detection)
- src/node.rs (new - module root)
- src/node/lockfile.rs (new - lockfile parsing)
- src/node/npm.rs (new - npm registry integration)
- README.md (updated status and examples)
- .ralph/prd.json (task-006 passes: true)

### Verified behavior
- `dotdeps add node:lodash` reads version from pnpm-lock.yaml/yarn.lock/package-lock.json
- `dotdeps add node:lodash@4.17.21` explicit version works
- `dotdeps add node:@types/node` scoped packages work correctly
- `dotdeps add node:express@4.18.0` fetches from npm, clones repo at correct tag
- Version not in lockfile shows helpful error message
- No lockfile found shows clear error message
- Cache hit reuses cached clone
- `dotdeps list` shows correct versions for all packages
- `dotdeps remove node:express` removes symlink correctly

### Next
- Implement Rust ecosystem (Cargo.lock parsing, crates.io repo detection)

## Iteration 6 - task-007: Rust ecosystem Cargo.lock parsing and crates.io repo detection

### Completed
- Created rust module with lockfile and crates_io submodules
- Implemented Cargo.lock parsing for version lookup
  - Handles TOML [[package]] array format
  - Crate names normalized (case-insensitive, - and _ equivalent)
- Implemented crates.io repo URL detection via JSON API
  - Uses /api/v1/crates/{name} endpoint
  - Includes User-Agent header for crates.io policy compliance
  - Falls back to homepage if repository not set
- Integrated into main.rs lookup_version and detect_repo_url
- 68 unit tests pass

### Key decisions
- Followed same module structure as python and node ecosystems
- Reused existing TOML and serde dependencies (no new deps needed)
- Crate name normalization mirrors Python's approach (- and _ equivalent)
- crates.io API requires User-Agent header, included for good citizenship

### Files changed
- src/rust.rs (new - module root)
- src/rust/lockfile.rs (new - Cargo.lock parsing)
- src/rust/crates_io.rs (new - crates.io API integration)
- src/main.rs (added rust module, wired lockfile and repo detection)
- README.md (updated status, examples, and ecosystem table)
- .ralph/prd.json (task-007 passes: true)

### Verified behavior
- `dotdeps add rust:serde` reads version from Cargo.lock (1.0.228)
- `dotdeps add rust:serde@1.0.228` explicit version clones at v1.0.228 tag
- `dotdeps add cargo:clap@4.5.0` cargo alias works, clones at v4.5.0 tag
- `dotdeps add rust:anyhow@1.0.0` clones at 1.0.0 tag (no v prefix)
- Cache hit on second add of same package
- `dotdeps list` shows rust:serde@1.0.228 format
- `dotdeps remove rust:tokio` removes symlink, preserves cache

### Next
- Implement Ruby ecosystem (Gemfile.lock parsing, RubyGems repo detection)

## Iteration 7 - task-008: Ruby ecosystem Gemfile.lock parsing and RubyGems repo detection

### Completed
- Created ruby module with lockfile and rubygems submodules
- Implemented Gemfile.lock parsing for version lookup
  - Handles custom Bundler format (not TOML/YAML)
  - Parses GEM specs section for gem names and versions
  - Strips platform suffixes (-x86_64-linux, -arm64-darwin, -java)
  - Handles multiple GEM sections (private registries)
- Implemented RubyGems repo URL detection via JSON API
  - Uses /api/v1/gems/{name}.json endpoint
  - Checks source_code_uri, falls back to homepage_uri
  - Strips GitHub UI paths (/tree/..., /blob/..., /releases/...)
- Gem names normalized (case-insensitive)
- 86 unit tests pass

### Key decisions
- Gemfile.lock uses custom format - implemented state machine parser
- Gems in specs are 4-space indented; dependencies are 6-space (skipped)
- RubyGems source_code_uri sometimes points to /tree/vX.X.X - stripped
- Followed same module structure as python, node, rust ecosystems
- No new dependencies needed (reuses ureq, serde_json)

### Files changed
- src/ruby.rs (new - module root)
- src/ruby/lockfile.rs (new - Gemfile.lock parsing)
- src/ruby/rubygems.rs (new - RubyGems API integration)
- src/main.rs (added ruby module, wired lockfile and repo detection)
- README.md (updated ecosystem table, examples, lockfile section)
- .ralph/prd.json (task-008 passes: true)

### Verified behavior
- `dotdeps add ruby:rails` reads version from Gemfile.lock (7.1.0)
- `dotdeps add ruby:rails@7.1.0` explicit version clones at v7.1.0 tag
- `dotdeps add ruby:sidekiq` fetches from RubyGems, clones at v7.2.0 tag
- `dotdeps add ruby:nokogiri` handles platform suffix (1.16.0-arm64-darwin -> 1.16.0)
- `dotdeps add ruby:puma@6.4.0` explicit version works
- Cache hit on second add of same package
- `dotdeps list` shows ruby:rails@7.1.0 format
- `dotdeps remove ruby:puma` removes symlink correctly
- No Gemfile.lock shows clear error message
- Gem not in lockfile shows helpful error message

### Next
- Implement Go ecosystem go.sum lockfile parsing (task-009)

## Iteration 8 - task-009: Go ecosystem go.sum lockfile parsing

### Completed
- Created go module with lockfile submodule
- Implemented go.sum parsing for version lookup
  - Handles standard format: `<module path> <version> <hash>`
  - Strips /go.mod suffix from version entries
  - Strips v prefix from versions for cache consistency
  - Module paths normalized (lowercase for matching)
- Integrated into main.rs lookup_version
- 91 unit tests pass (5 new Go tests)

### Key decisions
- Followed same module structure as python, node, rust, ruby ecosystems
- Go module paths are case-sensitive but we normalize for matching
- No separate registry module needed (repo URL detection already in main.rs)
- No new dependencies needed (reuses existing thiserror, std)

### Files changed
- src/go.rs (new - module root)
- src/go/lockfile.rs (new - go.sum parsing)
- src/main.rs (added go module, wired lockfile lookup)
- README.md (updated ecosystem table, examples, added Go section)
- .ralph/prd.json (task-009 passes: true)

### Verified behavior
- `dotdeps add go:github.com/gin-gonic/gin` reads version from go.sum (1.9.1)
- `dotdeps add go:golang.org/x/sync` reads version from go.sum (0.6.0)
- `dotdeps add go:github.com/example/pkg/v2` handles /v2 suffix correctly
- No go.sum found shows clear error message
- Module not in go.sum shows helpful error message
- Cache hit reuses cached clone
- `dotdeps list` shows go:github.com/gin-gonic/gin@1.9.1 format
- `dotdeps remove go:github.com/gin-gonic/gin` removes symlink correctly

### Next
- Implement config file support (task-010)

## Iteration 9 - task-010: Config file support

### Completed
- Created config module for ~/.config/dotdeps/config.json parsing
- Supports cache_limit_gb setting (default: 5GB)
- Supports per-ecosystem, per-package repo URL overrides
- Overrides checked first before ecosystem-specific detection
- Case-insensitive override lookup for package names
- Config file is optional (defaults used when not present)
- Clear error messages for malformed config files
- XDG_CONFIG_HOME environment variable respected
- 97 unit tests pass (6 new config tests)

### Key decisions
- Followed XDG Base Directory Specification for config location
- Overrides use nested structure: { "ecosystem": { "package": { "repo": "url" } } }
- Package names in overrides should be lowercase (lookup is case-insensitive)
- cache_limit_gb read but cache eviction not yet implemented (separate task)
- No new dependencies needed (reuses existing serde, serde_json)

### Files changed
- src/config.rs (new - config file parsing)
- src/main.rs (added config module, integrated overrides into detect_repo_url)
- README.md (added Configuration section, updated status)
- .ralph/prd.json (task-010 passes: true)

### Verified behavior
- `dotdeps add python:obscure-lib@4.17.21` uses override from config.json
- Override lookup is case-insensitive (Obscure-Lib -> obscure-lib)
- No config file present: defaults used, CLI works normally
- Malformed config file: clear parse error with file path and line number
- Non-overridden packages still use ecosystem-specific detection
- `dotdeps list` shows packages added with overrides correctly

### Next
- Implement cache eviction (LRU by atime)

## Iteration 10 - task-011: Cache eviction (LRU by atime)

### Completed
- Implemented cache eviction using LRU (least recently used) strategy
- CacheEntry struct tracks path, size (bytes), and access time for each cached package
- list_entries() recursively collects all version directories with .git folders
- get_dir_stats() calculates directory size and uses .git folder atime
- evict_to_limit() sorts by atime (oldest first), deletes until under limit
- cleanup_empty_parents() removes empty ecosystem/package directories after eviction
- Eviction runs automatically after each successful clone in add command
- Message printed when eviction occurs showing count and limit
- 97 unit tests pass

### Key decisions
- Access time from .git directory (more reliable than tracking all files)
- Eviction happens after clone, not before (simpler, allows single large packages)
- Empty parent directories cleaned up after eviction
- Cache limit of 0 means unlimited (no eviction)
- total_size() function provided for debugging/future use

### Files changed
- src/cache.rs (added CacheEntry, list_entries, evict_to_limit, get_dir_stats, etc.)
- src/config.rs (removed #[allow(dead_code)] from cache_limit_gb and cache_limit_bytes)
- src/main.rs (added run_cache_eviction, called after successful clone)
- README.md (updated status, marked cache eviction complete)
- .ralph/prd.json (task-011 passes: true)

### Verified behavior
- `dotdeps add python:pydantic@2.5.0` with 0.001GB limit triggers eviction
- Message shows "Cache eviction: removed 29 old entries to stay under 0.001GB limit"
- Empty cache directories cleaned up after eviction
- Normal usage with 5GB limit doesn't trigger eviction
- Eviction only runs after fresh clones (cache hits don't trigger)

### Next
- All core features implemented. Remaining tasks are polish/edge cases.

## Iteration 11 - task-019: Handle monorepo tag formats

### Completed
- Extended git clone tag resolution to support monorepo formats
- Tag resolution now tries in order:
  1. `v{version}` (e.g., `v1.0.0`) - most common format
  2. `{version}` (e.g., `1.0.0`) - used by some projects
  3. `{package}-{version}` (e.g., `tokio-1.0.0`) - monorepo format
  4. `{package}-v{version}` (e.g., `tokio-v1.0.0`) - monorepo format with v prefix
  5. Default branch (with warning)
- Added `build_tag_candidates()` to generate all candidate tags
- Added `extract_base_package_name()` for path-like package names
  - `github.com/org/repo` -> `repo`
  - `@scope/pkg` -> `pkg`
  - `simple-name` -> `simple-name`
- 103 unit tests pass (6 new tests)

### Key decisions
- Base package name extracted from path-like names for monorepo tags
- Tag candidates built once and iterated (cleaner than chained if statements)
- Existing v{version} and {version} formats remain highest priority
- Package name passed through from main.rs to git::clone()

### Files changed
- src/git.rs (refactored clone(), added build_tag_candidates, extract_base_package_name)
- src/main.rs (pass package name to git::clone)
- .ralph/prd.json (task-019 passes: true)

### Verified behavior
- `dotdeps add rust:tokio@1.0.0` clones at tokio-1.0.0 tag
- `dotdeps add rust:tokio-macros@2.0.0` clones at tokio-macros-2.0.0 tag
- `dotdeps add rust:serde@1.0.200` clones at v1.0.200 (standard format still works)
- `dotdeps add go:github.com/gin-gonic/gin@1.9.1` clones at v1.9.1 (Go still works)

### Next
- Implement Swift ecosystem (task-016) or git dependencies (task-012)

## Iteration 12 - task-016: Swift ecosystem Package.resolved parsing and repo detection

### Completed
- Added Swift to Ecosystem enum with aliases: swift, swiftpm, spm
- Created swift module with lockfile submodule
- Implemented Package.resolved parsing for both v1 and v2 formats
  - v1: object.pins[].package, repositoryURL, state.version
  - v2: pins[].identity, location, state.version
- Repo URL detection reads directly from Package.resolved (no registry API needed)
- Finds Package.resolved in multiple locations:
  - Direct: Package.resolved
  - Xcode project: *.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
  - Xcode workspace: *.xcworkspace/xcshareddata/swiftpm/Package.resolved
- Package identity matching supports both name and repo URL identity
- 111 unit tests pass (8 new Swift tests)

### Key decisions
- Swift repo URLs come from lockfile, not a registry API (simpler, more reliable)
- Support both v1 and v2 Package.resolved formats for backwards compatibility
- Package identity matching is flexible: matches by identity field or repo name
- Xcode project detection scans for .xcodeproj and .xcworkspace directories

### Files changed
- src/cli.rs (added Swift ecosystem with aliases)
- src/swift.rs (new - module root)
- src/swift/lockfile.rs (new - Package.resolved parsing)
- src/main.rs (added swift module, wired lookup_version and detect_repo_url)
- .ralph/prd.json (task-016 passes: true)

### Verified behavior
- `dotdeps add swift:swift-argument-parser` reads version from Package.resolved
- `dotdeps add swift:swift-collections` works with v2 format
- `dotdeps add swift:swift-nio` works with v1 format
- `dotdeps add swiftpm:...` and `dotdeps add spm:...` aliases work
- Xcode project Package.resolved detection works
- `dotdeps list` shows swift:package@version format
- `dotdeps remove swift:package` removes symlink correctly
- Cache hit on second add of same package
- Explicit version overrides lockfile version

### Next
- Implement git dependencies (task-012), local path deps (task-013), or bun.lock (task-015)

## Iteration 13 - task-012 & task-013: Git dependencies and local path dependencies

### Completed
- Added VersionInfo enum in cli.rs with variants:
  - Version(String) - regular registry versions
  - Git { url, commit } - git dependencies with URL and commit hash
  - LocalPath { path } - local path dependencies (skipped silently)
- Updated all ecosystem lockfile parsers to return VersionInfo
- Implemented git dependency detection:
  - Python: type = "git" with url and resolved_reference fields
  - Python: type = "directory" for local path deps
  - Node: git+https://, git+ssh://, git://, git@ URL formats in resolved/version fields
  - Node: link: and file: prefixes for local path deps
- Added clone_at_commit() in git.rs for cloning at specific commits
  - Uses blobless clone (--filter=blob:none) for efficient fetching
  - Checkout specific commit after clone
- Updated main.rs with three separate flows:
  - LocalPath: skip silently with info message
  - Git: clone from URL, use truncated commit as version in cache path
  - Version: existing registry detection and cloning flow
- SSH URLs (ssh://git@...) converted to HTTPS for reliable cloning
- 122 unit tests pass

### Key decisions
- VersionInfo enum cleanly separates version types at parse time
- Blobless clone for commit-based clones (fetches commits without blobs, on-demand file access)
- Commit hash truncated to 12 characters for cache path readability
- SSH URLs converted to HTTPS to avoid SSH key issues during clone
- Local path deps show "Skipping local dependency..." message (not silently ignored)

### Files changed
- src/cli.rs (added VersionInfo enum)
- src/python/lockfile.rs (added git/directory source detection)
- src/node/lockfile.rs (added git URL parsing, SSH to HTTPS conversion)
- src/go/lockfile.rs (updated to return VersionInfo)
- src/rust/lockfile.rs (updated to return VersionInfo)
- src/ruby/lockfile.rs (updated to return VersionInfo)
- src/swift/lockfile.rs (updated to return VersionInfo)
- src/git.rs (added clone_at_commit with blobless clone)
- src/main.rs (added VersionInfo handling with git/local/registry flows)
- .ralph/prd.json (task-012 and task-013 passes: true)

### Verified behavior
- Python git dep: poetry.lock with type="git" clones at commit hash
- Node git dep: package-lock.json with git+ssh:// URL clones correctly
- Local path dep: poetry.lock with type="directory" shows skip message
- Node local dep: link: and file: prefixes show skip message
- Cache uses truncated commit hash as version (12 chars)
- Symlink points to cache directory correctly
- `dotdeps list` shows package@commit format for git deps

### Next
- Implement bun.lock support (task-015), --json flag (task-017), or --dry-run flag (task-018)

## Iteration 14 - task-015: Support bun.lock files for Node.js ecosystem

### Completed
- Added Bun variant to LockfileType enum
- Added bun.lock to lockfile priority order (after package-lock.json)
- Implemented parse_bun_lock() function for JSONC format parsing
- Added strip_jsonc_trailing_commas() to handle JSONC trailing commas
- Implemented extract_version_from_bun_entry() for "name@version" parsing
- Handles both regular packages ("lodash") and scoped packages ("@types/node")
- Skips nested packages ("send/ms") to avoid incorrect version matching
- Added 8 new unit tests for bun.lock parsing
- 130 total unit tests pass

### Key decisions
- bun.lock is JSONC (JSON with trailing commas), not strict JSON
- Used custom strip_jsonc_trailing_commas() instead of adding a JSONC crate
- Package entries are arrays: ["name@version", "registry", {deps}, "integrity"]
- Nested packages like "send/ms" are ignored when looking up "ms"
- Priority order maintained: pnpm-lock.yaml > yarn.lock > package-lock.json > bun.lock

### Files changed
- src/node/lockfile.rs (added bun.lock support, 8 new tests)
- .ralph/prd.json (task-015 passes: true)

### Verified behavior
- `dotdeps add node:lodash` reads version from bun.lock (4.17.23)
- `dotdeps add node:@types/node` handles scoped packages correctly
- `dotdeps list` shows correct versions
- package-lock.json has higher priority than bun.lock when both exist

### Next
- Implement --json flag (task-017) or --dry-run flag (task-018)
