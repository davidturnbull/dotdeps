## Iteration 1 - task-001: CLI argument parsing

### Completed
- Set up Cargo project with Rust 2024 edition
- Implemented CLI argument parsing with clap derive macros
- Supports: add, remove, list subcommands and --clean flag
- Parses ecosystem:package@version syntax correctly
- Handles scoped packages (@org/pkg), Go module paths, version prefixes (v)
- Normalizes package names to lowercase and strips v prefix from versions
- 12 unit tests pass

### Key decisions
- Used clap derive API for declarative argument parsing
- DepSpec struct with FromStr for parsing dependency specifications
- Ecosystem enum with FromStr supporting aliases (npm->node, cargo->rust, etc.)
- Handle --clean vs subcommand conflict in main() rather than clap attribute

### Files changed
- Cargo.toml (new)
- src/main.rs (new)
- src/cli.rs (new)
- README.md (new)
- .ralph/prd.json (updated task-001 passes: true)

### Next
- task-002: Implement cache and .deps directory structure

## Iteration 2 - task-002 & task-005: Cache and .deps directory structure

### Completed
- Implemented cache module for ~/.cache/dotdeps/<ecosystem>/<package>/<version>/
- Implemented deps module for .deps/<ecosystem>/<package> symlinks
- Created symlinks with absolute paths to cache
- Windows detection with copy_dir_recursive fallback
- List command with broken symlink detection
- Remove command (removes symlink, preserves cache)
- Clean command (removes entire .deps/)
- Handles nested paths: scoped npm (@org/pkg), Go modules (github.com/org/repo/v2)
- XDG_CACHE_HOME environment variable respected
- 21 unit tests pass

### Key decisions
- Used `dirs` crate for cross-platform home directory detection
- Symlinks use absolute paths for reliability
- Cache existence checked via .git directory presence
- Empty ecosystem directories cleaned up on remove
- path and target fields in DepEntry kept for future debugging use

### Files changed
- Cargo.toml (added dirs dependency)
- src/main.rs (wired up cache and deps modules)
- src/cache.rs (new)
- src/deps.rs (new)
- README.md (updated status)
- .ralph/prd.json (task-002 and task-005 passes: true)

### Verified behavior
- `dotdeps add python:requests@2.31.0` creates symlink at .deps/python/requests
- `dotdeps add node:@org/pkg@4.17.21` handles scoped packages
- `dotdeps add go:github.com/org/repo/v2@1.0.0` handles Go module paths
- `dotdeps list` shows ecosystem:package@version format
- `dotdeps list` detects broken symlinks (cache evicted)
- `dotdeps remove python:requests` removes symlink, preserves cache
- `dotdeps --clean` removes entire .deps/ directory

### Next
- task-003: Implement git cloning with tag resolution

## Iteration 3 - task-003: Git cloning with tag resolution

### Completed
- Created git module with shallow clone functionality (--depth 1)
- Implemented tag resolution order: v{version} -> {version} -> default branch
- Added warning message when falling back to default branch
- Implemented cleanup of partial clone directories on failure
- Added Go ecosystem repo URL detection from module path
  - github.com/* -> https://github.com/*.git
  - golang.org/x/* -> https://go.googlesource.com/*.git
- 22 unit tests pass

### Key decisions
- Used std::process::Command for git operations (no external crate needed)
- CloneResult struct returns whether default branch was used and which ref was cloned
- Go modules get special treatment since package path IS the repo URL
- Other ecosystems return clear error message directing to config.json override
- Parent directories left in cache on failure (empty, no harm)

### Files changed
- src/git.rs (new)
- src/main.rs (wired in git module, added detect_repo_url function)
- README.md (updated status)
- .ralph/prd.json (task-003 passes: true)

### Verified behavior
- `dotdeps add go:github.com/gin-gonic/gin@1.9.1` clones at v1.9.1 tag
- `dotdeps add go:golang.org/x/sync@0.6.0` clones from go.googlesource.com
- Cache hit on second add of same package
- Nonexistent tag falls back to default branch with warning
- Clone failure cleans up partial directory
- Non-Go ecosystems show clear error about missing repo detection

### Next
- task-004: Implement Python ecosystem lockfile parsing and PyPI repo detection

## Iteration 4 - task-004: Python ecosystem lockfile parsing and PyPI repo detection

### Completed
- Created python module with lockfile and pypi submodules
- Implemented lockfile parsing for:
  - poetry.lock (TOML [[package]] array)
  - uv.lock (TOML [[package]] array)
  - requirements.txt (exact pins: package==version)
  - pyproject.toml (tool.poetry.dependencies and project.dependencies PEP 621)
- Implemented PyPI repo URL detection via JSON API
  - Checks project_urls for Source, Repository, GitHub keys
  - Falls back to home_page if it looks like a git repo
- Integrated lockfile lookup into add command when version is omitted
- Python package names normalized (case-insensitive, - and _ equivalent)
- 35 unit tests pass

### Key decisions
- Used toml crate for TOML parsing with serde deserialization
- Used ureq for HTTP requests (minimal dependency footprint)
- Used serde_json for PyPI JSON API parsing
- Lockfile search walks up directory tree to find nearest lockfile
- Lockfile priority: poetry.lock > uv.lock > requirements.txt > pyproject.toml
- requirements.txt only returns exact versions (== pins) for reliability
- pyproject.toml supports both Poetry-style and PEP 621-style dependencies
- Go repo detection refactored to use regex-like version suffix stripping

### Files changed
- Cargo.toml (added serde, serde_json, toml, ureq dependencies)
- src/main.rs (added python module, lookup_version function, updated detect_repo_url)
- src/python.rs (new - module root)
- src/python/lockfile.rs (new - lockfile parsing)
- src/python/pypi.rs (new - PyPI API integration)
- README.md (updated status and examples)
- .ralph/prd.json (task-004 passes: true)

### Verified behavior
- `dotdeps add python:requests` reads version from poetry.lock/uv.lock/etc.
- `dotdeps add python:flask` fetches from PyPI, clones repo at correct tag
- `dotdeps add python:typing-extensions` normalizes package name with hyphens
- `dotdeps add python:httpx@0.25.0` explicit version overrides lockfile
- Version not in lockfile shows helpful error message
- No lockfile found shows clear error message
- Cache hit reuses cached clone
- `dotdeps list` shows correct versions

### Next
- Implement Node.js ecosystem (pnpm-lock.yaml, yarn.lock, package-lock.json, npm registry)

## Iteration 5 - task-006: Node.js ecosystem lockfile parsing and npm registry detection

### Completed
- Created node module with lockfile and npm submodules
- Implemented lockfile parsing for:
  - pnpm-lock.yaml (YAML, lockfileVersion 9.0)
  - yarn.lock (custom format, not YAML - line-based parser)
  - package-lock.json (JSON, lockfileVersion 1, 2, and 3)
- Implemented npm registry repo URL detection
  - Handles repository field as string or object
  - Handles various URL formats: git+https, git://, git@, github: shorthand
  - Falls back to homepage if it looks like a git repo
- Scoped packages (@org/pkg) handled correctly in all parsers
- Package names normalized to lowercase for cache consistency
- 60 unit tests pass

### Key decisions
- Used serde_yml for YAML parsing
- yarn.lock is NOT valid YAML - implemented custom line-based parser
- Package version extracted from lockfile key (name@version) rather than nested structure
- npm repository URL normalization handles many edge cases (git+, ssh, shorthand)
- is_known_git_host() checks for known hosts before adding .git suffix

### Files changed
- Cargo.toml (added serde_yml dependency)
- src/main.rs (added node module, wired lockfile and repo detection)
- src/node.rs (new - module root)
- src/node/lockfile.rs (new - lockfile parsing)
- src/node/npm.rs (new - npm registry integration)
- README.md (updated status and examples)
- .ralph/prd.json (task-006 passes: true)

### Verified behavior
- `dotdeps add node:lodash` reads version from pnpm-lock.yaml/yarn.lock/package-lock.json
- `dotdeps add node:lodash@4.17.21` explicit version works
- `dotdeps add node:@types/node` scoped packages work correctly
- `dotdeps add node:express@4.18.0` fetches from npm, clones repo at correct tag
- Version not in lockfile shows helpful error message
- No lockfile found shows clear error message
- Cache hit reuses cached clone
- `dotdeps list` shows correct versions for all packages
- `dotdeps remove node:express` removes symlink correctly

### Next
- Implement Rust ecosystem (Cargo.lock parsing, crates.io repo detection)

## Iteration 6 - task-007: Rust ecosystem Cargo.lock parsing and crates.io repo detection

### Completed
- Created rust module with lockfile and crates_io submodules
- Implemented Cargo.lock parsing for version lookup
  - Handles TOML [[package]] array format
  - Crate names normalized (case-insensitive, - and _ equivalent)
- Implemented crates.io repo URL detection via JSON API
  - Uses /api/v1/crates/{name} endpoint
  - Includes User-Agent header for crates.io policy compliance
  - Falls back to homepage if repository not set
- Integrated into main.rs lookup_version and detect_repo_url
- 68 unit tests pass

### Key decisions
- Followed same module structure as python and node ecosystems
- Reused existing TOML and serde dependencies (no new deps needed)
- Crate name normalization mirrors Python's approach (- and _ equivalent)
- crates.io API requires User-Agent header, included for good citizenship

### Files changed
- src/rust.rs (new - module root)
- src/rust/lockfile.rs (new - Cargo.lock parsing)
- src/rust/crates_io.rs (new - crates.io API integration)
- src/main.rs (added rust module, wired lockfile and repo detection)
- README.md (updated status, examples, and ecosystem table)
- .ralph/prd.json (task-007 passes: true)

### Verified behavior
- `dotdeps add rust:serde` reads version from Cargo.lock (1.0.228)
- `dotdeps add rust:serde@1.0.228` explicit version clones at v1.0.228 tag
- `dotdeps add cargo:clap@4.5.0` cargo alias works, clones at v4.5.0 tag
- `dotdeps add rust:anyhow@1.0.0` clones at 1.0.0 tag (no v prefix)
- Cache hit on second add of same package
- `dotdeps list` shows rust:serde@1.0.228 format
- `dotdeps remove rust:tokio` removes symlink, preserves cache

### Next
- Implement Ruby ecosystem (Gemfile.lock parsing, RubyGems repo detection)

## Iteration 7 - task-008: Ruby ecosystem Gemfile.lock parsing and RubyGems repo detection

### Completed
- Created ruby module with lockfile and rubygems submodules
- Implemented Gemfile.lock parsing for version lookup
  - Handles custom Bundler format (not TOML/YAML)
  - Parses GEM specs section for gem names and versions
  - Strips platform suffixes (-x86_64-linux, -arm64-darwin, -java)
  - Handles multiple GEM sections (private registries)
- Implemented RubyGems repo URL detection via JSON API
  - Uses /api/v1/gems/{name}.json endpoint
  - Checks source_code_uri, falls back to homepage_uri
  - Strips GitHub UI paths (/tree/..., /blob/..., /releases/...)
- Gem names normalized (case-insensitive)
- 86 unit tests pass

### Key decisions
- Gemfile.lock uses custom format - implemented state machine parser
- Gems in specs are 4-space indented; dependencies are 6-space (skipped)
- RubyGems source_code_uri sometimes points to /tree/vX.X.X - stripped
- Followed same module structure as python, node, rust ecosystems
- No new dependencies needed (reuses ureq, serde_json)

### Files changed
- src/ruby.rs (new - module root)
- src/ruby/lockfile.rs (new - Gemfile.lock parsing)
- src/ruby/rubygems.rs (new - RubyGems API integration)
- src/main.rs (added ruby module, wired lockfile and repo detection)
- README.md (updated ecosystem table, examples, lockfile section)
- .ralph/prd.json (task-008 passes: true)

### Verified behavior
- `dotdeps add ruby:rails` reads version from Gemfile.lock (7.1.0)
- `dotdeps add ruby:rails@7.1.0` explicit version clones at v7.1.0 tag
- `dotdeps add ruby:sidekiq` fetches from RubyGems, clones at v7.2.0 tag
- `dotdeps add ruby:nokogiri` handles platform suffix (1.16.0-arm64-darwin -> 1.16.0)
- `dotdeps add ruby:puma@6.4.0` explicit version works
- Cache hit on second add of same package
- `dotdeps list` shows ruby:rails@7.1.0 format
- `dotdeps remove ruby:puma` removes symlink correctly
- No Gemfile.lock shows clear error message
- Gem not in lockfile shows helpful error message

### Next
- Implement Go ecosystem go.sum lockfile parsing (task-009)

## Iteration 8 - task-009: Go ecosystem go.sum lockfile parsing

### Completed
- Created go module with lockfile submodule
- Implemented go.sum parsing for version lookup
  - Handles standard format: `<module path> <version> <hash>`
  - Strips /go.mod suffix from version entries
  - Strips v prefix from versions for cache consistency
  - Module paths normalized (lowercase for matching)
- Integrated into main.rs lookup_version
- 91 unit tests pass (5 new Go tests)

### Key decisions
- Followed same module structure as python, node, rust, ruby ecosystems
- Go module paths are case-sensitive but we normalize for matching
- No separate registry module needed (repo URL detection already in main.rs)
- No new dependencies needed (reuses existing thiserror, std)

### Files changed
- src/go.rs (new - module root)
- src/go/lockfile.rs (new - go.sum parsing)
- src/main.rs (added go module, wired lockfile lookup)
- README.md (updated ecosystem table, examples, added Go section)
- .ralph/prd.json (task-009 passes: true)

### Verified behavior
- `dotdeps add go:github.com/gin-gonic/gin` reads version from go.sum (1.9.1)
- `dotdeps add go:golang.org/x/sync` reads version from go.sum (0.6.0)
- `dotdeps add go:github.com/example/pkg/v2` handles /v2 suffix correctly
- No go.sum found shows clear error message
- Module not in go.sum shows helpful error message
- Cache hit reuses cached clone
- `dotdeps list` shows go:github.com/gin-gonic/gin@1.9.1 format
- `dotdeps remove go:github.com/gin-gonic/gin` removes symlink correctly

### Next
- Implement config file support (task-010)

## Iteration 9 - task-010: Config file support

### Completed
- Created config module for ~/.config/dotdeps/config.json parsing
- Supports cache_limit_gb setting (default: 5GB)
- Supports per-ecosystem, per-package repo URL overrides
- Overrides checked first before ecosystem-specific detection
- Case-insensitive override lookup for package names
- Config file is optional (defaults used when not present)
- Clear error messages for malformed config files
- XDG_CONFIG_HOME environment variable respected
- 97 unit tests pass (6 new config tests)

### Key decisions
- Followed XDG Base Directory Specification for config location
- Overrides use nested structure: { "ecosystem": { "package": { "repo": "url" } } }
- Package names in overrides should be lowercase (lookup is case-insensitive)
- cache_limit_gb read but cache eviction not yet implemented (separate task)
- No new dependencies needed (reuses existing serde, serde_json)

### Files changed
- src/config.rs (new - config file parsing)
- src/main.rs (added config module, integrated overrides into detect_repo_url)
- README.md (added Configuration section, updated status)
- .ralph/prd.json (task-010 passes: true)

### Verified behavior
- `dotdeps add python:obscure-lib@4.17.21` uses override from config.json
- Override lookup is case-insensitive (Obscure-Lib -> obscure-lib)
- No config file present: defaults used, CLI works normally
- Malformed config file: clear parse error with file path and line number
- Non-overridden packages still use ecosystem-specific detection
- `dotdeps list` shows packages added with overrides correctly

### Next
- Implement cache eviction (LRU by atime)

## Iteration 10 - task-011: Cache eviction (LRU by atime)

### Completed
- Implemented cache eviction using LRU (least recently used) strategy
- CacheEntry struct tracks path, size (bytes), and access time for each cached package
- list_entries() recursively collects all version directories with .git folders
- get_dir_stats() calculates directory size and uses .git folder atime
- evict_to_limit() sorts by atime (oldest first), deletes until under limit
- cleanup_empty_parents() removes empty ecosystem/package directories after eviction
- Eviction runs automatically after each successful clone in add command
- Message printed when eviction occurs showing count and limit
- 97 unit tests pass

### Key decisions
- Access time from .git directory (more reliable than tracking all files)
- Eviction happens after clone, not before (simpler, allows single large packages)
- Empty parent directories cleaned up after eviction
- Cache limit of 0 means unlimited (no eviction)
- total_size() function provided for debugging/future use

### Files changed
- src/cache.rs (added CacheEntry, list_entries, evict_to_limit, get_dir_stats, etc.)
- src/config.rs (removed #[allow(dead_code)] from cache_limit_gb and cache_limit_bytes)
- src/main.rs (added run_cache_eviction, called after successful clone)
- README.md (updated status, marked cache eviction complete)
- .ralph/prd.json (task-011 passes: true)

### Verified behavior
- `dotdeps add python:pydantic@2.5.0` with 0.001GB limit triggers eviction
- Message shows "Cache eviction: removed 29 old entries to stay under 0.001GB limit"
- Empty cache directories cleaned up after eviction
- Normal usage with 5GB limit doesn't trigger eviction
- Eviction only runs after fresh clones (cache hits don't trigger)

### Next
- All core features implemented. Remaining tasks are polish/edge cases.
